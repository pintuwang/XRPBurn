<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XRPBurn Analysis Daily</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f4f4f9; }
        .controls { margin-bottom: 20px; display: flex; align-items: center; gap: 15px; }
        .chart-wrapper { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .dot-legend { font-size: 0.8em; margin-top: 10px; margin-bottom: 20px; }
        button { padding: 8px 15px; cursor: pointer; background: #0c2c56; color: white; border: none; border-radius: 4px; }
        canvas { width: 100% !important; height: 400px !important; }

        /* Null-data warning banner */
        .data-warning {
            background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;
            padding: 8px 14px; font-size: 0.82em; color: #856404;
            display: none; margin-bottom: 16px;
        }
    </style>
</head>
<body>

    <h1>XRPBurn Analysis Daily</h1>
    <p>Last updated: <span id="last-update">-</span> (SGT)</p>

    <div id="data-warning" class="data-warning"></div>

    <div class="controls">
        <button onclick="triggerUpdate()">Update Now</button>
        <label>
            <input type="checkbox" id="rollup-toggle" onchange="loadData()"> Roll up to Monthly
        </label>
    </div>

    <div class="chart-wrapper">
        <h3>Network Load (Categorized USD M) vs. XRP Burn</h3>
        <canvas id="loadChart"></canvas>
    </div>

    <div class="chart-wrapper">
        <h3>Transaction Breakdown (Categorized Millions)</h3>
        <canvas id="txChart"></canvas>
    </div>

    <div class="dot-legend">
        ğŸ”µ Saturday | ğŸ”´ Sunday | ğŸˆ Simulated / XRPL Unreachable
    </div>

    <script>
        let rawData = [];
        let loadChartInstance = null;
        let txChartInstance = null;

        const colors = {
            settlement: '#2ca02c',
            identity:   '#9467bd',
            defi:       '#ff7f0e',
            acct_mgmt:  '#7f7f7f',
            pending:    '#a5c8ed'   // blue "In Progress" bar
        };

        // â”€â”€ Plugins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        const fallbackIconPlugin = {
            id: 'fallbackIcon',
            afterDraw: (chart) => {
                const { ctx, scales: { x, y } } = chart;
                chart.data.labels.forEach((label) => {
                    const entry = rawData.find(d => d.date === label);
                    if (entry && entry.is_fallback) {
                        const xPos = x.getPixelForValue(label);
                        ctx.font = '16px serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸˆ', xPos, y.top + 20);
                    }
                });
            }
        };

        const weekendDotsPlugin = {
            id: 'weekendDots',
            afterDraw: (chart) => {
                const { ctx, scales: { x } } = chart;
                chart.data.labels.forEach((label) => {
                    const date = new Date(label);
                    const day = date.getDay();
                    if (day === 6 || day === 0) {
                        ctx.fillStyle = (day === 6) ? 'blue' : 'red';
                        ctx.beginPath();
                        ctx.arc(x.getPixelForValue(label), x.bottom + 15, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            }
        };

        // â”€â”€ Data loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async function loadData() {
            try {
                // Cache-bust so GitHub Pages serves the latest data.json
                const response = await fetch('data.json?v=' + Date.now());
                rawData = await response.json();

                if (rawData.length > 0) {
                    const last = rawData[rawData.length - 1];
                    document.getElementById('last-update').innerText =
                        last.last_updated || last.date;
                }

                checkDataWarnings();
                renderCharts();
            } catch (error) {
                console.error("Error loading data:", error);
                document.getElementById('last-update').innerText = 'Error loading data';
            }
        }

        function checkDataWarnings() {
            const warningEl = document.getElementById('data-warning');
            const simulated = rawData.filter(d => d.is_fallback);
            if (simulated.length > 0) {
                const dates = simulated.map(d => d.date).join(', ');
                warningEl.style.display = 'block';
                warningEl.innerHTML =
                    `âš ï¸ <strong>${simulated.length} day(s) contain simulated data</strong>` +
                    ` (XRPL node was unreachable during scheduled update): <em>${dates}</em>. ` +
                    `These are marked with ğŸˆ on the charts.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // â”€â”€ Chart rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function renderCharts() {
            const isMonthly = document.getElementById('rollup-toggle').checked;
            let displayData = isMonthly ? rollUpMonthly(rawData) : rawData;

            const catKeys = ['settlement', 'identity', 'defi', 'acct_mgmt'];

            // Destroy previous instances
            if (loadChartInstance) loadChartInstance.destroy();
            if (txChartInstance)   txChartInstance.destroy();

            // â”€â”€ Load Chart â”€â”€

            const loadDatasets = catKeys.map(cat => ({
                label: catLabel(cat),
                data: displayData.map(d =>
                    hasCategories(d.load_categories) ? (d.load_categories[cat] || 0) : 0
                ),
                backgroundColor: colors[cat],
                stack: 'Stack 0'
            }));

            // "In Progress" bar covers days where category breakdown is not yet available
            loadDatasets.push({
                label: 'In Progress',
                data: displayData.map(d =>
                    !hasCategories(d.load_categories) ? (d.load_usd_m || 0) : 0
                ),
                backgroundColor: colors.pending,
                stack: 'Stack 0'
            });

            // Burn line on secondary y-axis â€” only plot non-null values
            const burnLine = {
                label: 'Actual XRP Burn',
                data: displayData.map(d => d.burn_xrp ?? null),
                borderColor: 'red',
                backgroundColor: 'rgba(255,0,0,0.1)',
                type: 'line',
                yAxisID: 'y1',
                spanGaps: false   // gaps where burn is null
            };

            loadChartInstance = new Chart(
                document.getElementById('loadChart').getContext('2d'),
                {
                    type: 'bar',
                    data: {
                        labels: displayData.map(d => d.date),
                        datasets: [...loadDatasets, burnLine]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const val = ctx.raw;
                                        if (val === null || val === undefined) return null;
                                        return `${ctx.dataset.label}: ${
                                            ctx.dataset.yAxisID === 'y1'
                                                ? val + ' XRP'
                                                : '$' + val.toFixed(2) + 'M'
                                        }`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x:  { stacked: true },
                            y:  { stacked: true, title: { display: true, text: 'USD Millions' } },
                            y1: {
                                position: 'right',
                                grid: { drawOnChartArea: false },
                                title: { display: true, text: 'XRP Burned' }
                            }
                        }
                    },
                    plugins: [weekendDotsPlugin, fallbackIconPlugin]
                }
            );

            // â”€â”€ TX Chart â”€â”€

            const txDatasets = catKeys.map(cat => ({
                label: catLabel(cat),
                data: displayData.map(d =>
                    hasCategories(d.tx_categories) ? (d.tx_categories[cat] || 0) : 0
                ),
                backgroundColor: colors[cat],
                stack: 'Stack 0'
            }));

            txDatasets.push({
                label: 'In Progress',
                data: displayData.map(d =>
                    !hasCategories(d.tx_categories) ? (d.transactions || 0) : 0
                ),
                backgroundColor: colors.pending,
                stack: 'Stack 0'
            });

            txChartInstance = new Chart(
                document.getElementById('txChart').getContext('2d'),
                {
                    type: 'bar',
                    data: {
                        labels: displayData.map(d => d.date),
                        datasets: txDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const val = ctx.raw;
                                        if (!val) return null;
                                        return `${ctx.dataset.label}: ${val.toFixed(3)}M txs`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { stacked: true },
                            y: { stacked: true, title: { display: true, text: 'Transactions (Millions)' } }
                        }
                    },
                    plugins: [weekendDotsPlugin, fallbackIconPlugin]
                }
            );
        }

        // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        /**
         * A category object is "real" only if it exists AND has at least one non-zero value.
         * Empty {} or all-zero values both trigger the "In Progress" blue bar.
         */
        function hasCategories(cats) {
            return cats &&
                   typeof cats === 'object' &&
                   Object.keys(cats).length > 0 &&
                   Object.values(cats).some(v => v > 0);
        }

        function catLabel(key) {
            return { settlement: 'Settlement', identity: 'Identity',
                     defi: 'DeFi', acct_mgmt: 'Acct Mgmt' }[key] || key;
        }

        /** Roll up daily entries to monthly averages / sums */
        function rollUpMonthly(data) {
            const months = {};
            data.forEach(d => {
                const m = d.date.slice(0, 7); // "YYYY-MM"
                if (!months[m]) months[m] = { entries: [], date: m + '-01', is_fallback: false };
                months[m].entries.push(d);
                if (d.is_fallback) months[m].is_fallback = true;
            });

            return Object.values(months).map(({ entries, date, is_fallback }) => {
                const n = entries.length;
                const avg = key => {
                    const vals = entries.map(e => e[key]).filter(v => v != null);
                    return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
                };
                const sumCat = (field, cat) => {
                    const vals = entries.map(e => (e[field] || {})[cat] || 0);
                    return vals.reduce((a, b) => a + b, 0);
                };
                const catKeys = ['settlement', 'identity', 'defi', 'acct_mgmt'];
                const hasCat = entries.some(e => hasCategories(e.tx_categories));

                return {
                    date,
                    last_updated: date,
                    burn_xrp:  avg('burn_xrp'),
                    load_usd_m: avg('load_usd_m'),
                    transactions: avg('transactions'),
                    tx_categories: hasCat ? Object.fromEntries(catKeys.map(k => [k, sumCat('tx_categories', k)])) : {},
                    load_categories: hasCat ? Object.fromEntries(catKeys.map(k => [k, sumCat('load_categories', k)])) : {},
                    is_fallback
                };
            });
        }

        // â”€â”€ GitHub Actions trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async function triggerUpdate() {
            const token = prompt("Enter GitHub Personal Access Token:");
            if (!token) return;
            const response = await fetch(
                `https://api.github.com/repos/pintuwang/xrpburn/actions/workflows/daily_update.yml/dispatches`,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({ ref: 'main' })
                }
            );
            alert(response.ok
                ? "âœ… Update triggered! Check Actions tab for progress."
                : `âŒ Failed (${response.status}). Check your token has 'workflow' scope.`
            );
        }

        window.onload = loadData;
    </script>
</body>
</html>
